做一个华容道bfs算法. 算法核心思想就是bfs遍历每一次可以走的步奏,然后记录下棋盘到最终结果之间的路径.
遇到可以走通的棋盘就用字典记录下来走法.这样保证了所有尝试做过后会遇到解.


# 困难点主要在把游戏转化为语言编码上的难度.





#==========我们做一个一般解. 也就是随便给出一个棋盘. 都能解.





# 首先这个游戏分下面几种情况.
# 1曹操4兵:    3横2竖
               4横一竖
               2横3竖
               5横
               1横4竖
               5竖

# 然后我们先用最笨最直观的编码方式, 也就是用一个二维数组来表示整个棋盘.

曹操1,竖线2,横线3, 小兵4
来填充整个二维数组.
比如棋盘1:

1 1 2 2
1 1 2 2
4 4 2 2
4 4 2 2
0 0 3 3
我们看这种编码是否能唯一表示一个棋盘.
这里面最困难的就是2,3的编码是否表示唯一的棋盘.


也就是是否给定编码之后, 能区分出每一个2上,还是2下. 3左还是3右
是否需要用2上,2下来替代2的编码?
我目前的理解是不如输入的时候就用21表示2上,22表示2下.31表示左横,32表示右横.
#########后续如果发现没必要的话再改.



demo棋盘


1 1 21 21
1 1 22 22
4 4 21 21
4 4 22 22
0 0 31 32




if 1:#=========这个是numpy str互化的方法.
    from numpy import array
    a = array([[0,3,5],[2,3,4]])
    a_str = a.__repr__() # 'array([[0, 3, 5],\n       [2, 3, 4]])'
    a2 = eval(a_str)
    print(a2,88888888888888)






#==========2021-10-24,19点29


华容道解法.运行
main_by_numpy2.py

































